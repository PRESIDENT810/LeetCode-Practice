## 326. 3的幂 （我果然是算法废物。。。）

- 整数限制
一个重要的信息可以从函数名中推导出来。

```java
public boolean isPowerOfThree(int n)
``` 

我们可以看出 n 的类型是 int。在 Java 中说明了该变量是四个字节，他的最大值为 2147483647

知道了 n 的限制，我们现在可以推断出 n 的最大值，也就是 3 的幂，是 1162261467。

因此，我们应该返回 true 的 n 的可能值是 3^0，3^1，... 3^19。
因为 3 是质数，所以 3^19 的除数只有 3^0，3^1，... 3^19。

因此我们只需要将 3^19 除以 n。若余数为 0 意味着 n 是 3^19的除数，因此是 3 的幂。


## 448. 找到所有数组中消失的数字

- 原地修改

我们需要知道数组中存在的数字，由于数组的元素取值范围是 \[1, N\]，所以我们可以不使用额外的空间去解决它。
我们可以在输入数组本身以某种方式标记已访问过的数字，然后再找到缺失的数字。
算法：

遍历输入数组的每个元素一次。
我们将把 abs(nums\[i\])-1 索引位置的元素标记为负数。即 

nums\[abs(nums\[i\])−1\] *= −1 。

然后遍历数组，若当前数组元素 nums\[i\] 为负数，说明我们在数组中存在数字 i+1。

Note:

1. 由于数字范围为\[1, N\]， **数字范围与索引范围是一一映射的**，故可以**利用数组索引存储额外的关于已经遍历的数字的信息**
2. 要**利用数组索引存储额外信息**，又**不能丢失原有信息**（不能替换数组中其它元素），可以**将数组对应位置的数字乘-1来表示已经遍历的数字**

（由于数组中数字都大于0，所以乘-1不会丢失原有信息，负数则表示这个索引对应数字已被遍历）

## 994. 腐烂的橘子

本题跟树结构并不完全相同，因为可能有新鲜的橘子会被两个方向的腐烂的橘子感染，此时不能理解成树结构而是图结构

本题跟MST思路较类似，从所有腐烂橘子为源头，连接到所有新鲜的橘子，每条连线权重为1，找到拥有最大权重之和的节点

同样可以使用BFS的方式进行寻找，维护一个腐烂橘子队列，每次拿出一个，将与其相邻的新鲜橘子放入队列

这样就避免DFS可能会出现两个腐烂橘子一起感染一个新鲜的橘子的时间不对的问题

例如：2-1-1-1-2

DFS时，感染路径2-1-1-1，用时3分钟；感染路径1-1-1-2：用时3分钟。但正确用时是2分钟（两个烂橘子一起感染）

BFS时则不会：1分钟时 2-1 / 1-2； 2分钟时2-1-1 / 1-2 感染完毕

## 5323. 根据数字二进制下1的数目排序

想了半天才反应过来这本质还是个排序问题。。。跟平常的排序不一样的地方就是判断大小
的依据变成了二进制下1的数目而已

然而我已经忘记怎么写快排了。。。瞎jb对付了一个冒泡排序暴力过了

（待更新标准解法

## 5325. 包含所有三种字符的子字符串数目

```java
    long all_sub = s.length()*(s.length()+1)/2;
```

太草了，最后一分钟提交结果卡在这个int乘法溢出上，佛了

问题出在虽然结果被声明为long了，但是计算时s.length()仍然是按int类型计算，
所以进行乘法的时候还是会溢出，这里需要先把这个字符串的长度变为long，
然后进行乘法计算，long的话乘法就不会有溢出问题了

```java
    long len = s.length();
    long all_sub = len*(len+1)/2;
```

我的做法见韦恩图。。。不知道有没有更快的解法

![](./Asset/Q5325.jpeg)

## 面试题57 - II. 和为s的连续正数序列

不知道为啥理论上都是O(N)的算法，时间却差的很多。。。

在这里，我们考虑以9为例子，9可以被拆开成4+5。为了得到4我们需要思考一下。
根据规律如果是\[4,5\]的话，i=2，target % 2 = 0 其中\[4,5\]可以改写成4+(4+1)。 
在考虑三个元素的时候 2+3+4 我们发现 他可以被写成 2+(2+1)+(2+2) target%3 = 0。

似乎有点规律，我们不妨用开始元素x元素个数 你会发现如果target刚好为这个值的话，也能满足target%i=0 

那我们如何让target的值等于我们需要的值呢？根据刚才的变式，我们发现只要让target逐次减去(1,2,3,....)
并且当target%i = 0 的时候返回这个target/i就是我们需要的值了。