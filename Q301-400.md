## 326. 3的幂 （我果然是算法废物。。。）

- 整数限制
一个重要的信息可以从函数名中推导出来。

```java
public boolean isPowerOfThree(int n)
``` 

我们可以看出 n 的类型是 int。在 Java 中说明了该变量是四个字节，他的最大值为 2147483647

知道了 n 的限制，我们现在可以推断出 n 的最大值，也就是 3 的幂，是 1162261467。

因此，我们应该返回 true 的 n 的可能值是 3^0，3^1，... 3^19。
因为 3 是质数，所以 3^19 的除数只有 3^0，3^1，... 3^19。

因此我们只需要将 3^19 除以 n。若余数为 0 意味着 n 是 3^19的除数，因此是 3 的幂。


## 448. 找到所有数组中消失的数字

- 原地修改

我们需要知道数组中存在的数字，由于数组的元素取值范围是 \[1, N\]，所以我们可以不使用额外的空间去解决它。
我们可以在输入数组本身以某种方式标记已访问过的数字，然后再找到缺失的数字。
算法：

遍历输入数组的每个元素一次。
我们将把 abs(nums\[i\])-1 索引位置的元素标记为负数。即 

nums\[abs(nums\[i\])−1\] *= −1 。

然后遍历数组，若当前数组元素 nums\[i\] 为负数，说明我们在数组中存在数字 i+1。

Note:

1. 由于数字范围为\[1, N\]， **数字范围与索引范围是一一映射的**，故可以**利用数组索引存储额外的关于已经遍历的数字的信息**
2. 要**利用数组索引存储额外信息**，又**不能丢失原有信息**（不能替换数组中其它元素），可以**将数组对应位置的数字乘-1来表示已经遍历的数字**

（由于数组中数字都大于0，所以乘-1不会丢失原有信息，负数则表示这个索引对应数字已被遍历）

## 5323. 根据数字二进制下1的数目排序

想了半天才反应过来这本质还是个排序问题。。。跟平常的排序不一样的地方就是判断大小
的依据变成了二进制下1的数目而已

然而我已经忘记怎么写快排了。。。瞎jb对付了一个冒泡排序暴力过了

（待更新标准解法

## 5325. 包含所有三种字符的子字符串数目

```java
    long all_sub = s.length()*(s.length()+1)/2;
```

太草了，最后一分钟提交结果卡在这个int乘法溢出上，佛了

问题出在虽然结果被声明为long了，但是计算时s.length()仍然是按int类型计算，
所以进行乘法的时候还是会溢出，这里需要先把这个字符串的长度变为long，
然后进行乘法计算，long的话乘法就不会有溢出问题了

```java
    long len = s.length();
    long all_sub = len*(len+1)/2;
```

我的做法见韦恩图。。。不知道有没有更快的解法

![](./Asset/Q5325.jpeg)