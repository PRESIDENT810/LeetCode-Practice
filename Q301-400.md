## 322. 零钱兑换

自己一开始的解法差一点就可以通过了。。。

一开始的做法里，要凑某个面额时，从一个记录了所有可以凑出来的金额的集合里面遍历凑数：
`for (int available : this.set)`

但实际上所有已经凑出来的金额都是用一开始给的coins凑出来的。。。所以遍历coins就可以了，
遍历集合的话会重复遍历很多情况

例如coins = {1,2,5}, amount = 11时，遍历4+7=11时，4=2+2，
所以这个情况在遍历到2时已经被考虑过了(2+9=11)

## 326. 3的幂 （我果然是算法废物。。。）

- 整数限制
一个重要的信息可以从函数名中推导出来。

```java
public boolean isPowerOfThree(int n)
``` 

我们可以看出 n 的类型是 int。在 Java 中说明了该变量是四个字节，他的最大值为 2147483647

知道了 n 的限制，我们现在可以推断出 n 的最大值，也就是 3 的幂，是 1162261467。

因此，我们应该返回 true 的 n 的可能值是 3^0，3^1，... 3^19。
因为 3 是质数，所以 3^19 的除数只有 3^0，3^1，... 3^19。

因此我们只需要将 3^19 除以 n。若余数为 0 意味着 n 是 3^19的除数，因此是 3 的幂。


## 448. 找到所有数组中消失的数字

- 原地修改

我们需要知道数组中存在的数字，由于数组的元素取值范围是 \[1, N\]，所以我们可以不使用额外的空间去解决它。
我们可以在输入数组本身以某种方式标记已访问过的数字，然后再找到缺失的数字。
算法：

遍历输入数组的每个元素一次。
我们将把 abs(nums\[i\])-1 索引位置的元素标记为负数。即 

nums\[abs(nums\[i\])−1\] *= −1 。

然后遍历数组，若当前数组元素 nums\[i\] 为负数，说明我们在数组中存在数字 i+1。

Note:

1. 由于数字范围为\[1, N\]， **数字范围与索引范围是一一映射的**，故可以**利用数组索引存储额外的关于已经遍历的数字的信息**
2. 要**利用数组索引存储额外信息**，又**不能丢失原有信息**（不能替换数组中其它元素），可以**将数组对应位置的数字乘-1来表示已经遍历的数字**

（由于数组中数字都大于0，所以乘-1不会丢失原有信息，负数则表示这个索引对应数字已被遍历）

## 914 卡牌分组

你的GCD：
```java
    public int GCD(int n1, int n2){
        if (n2 == 0) return n1;
        while (true){
            if (n1 > n2){
                if (n1%n2 == 0) return n2;
                n1 %= n2;
                continue;
            }
            else{
                if (n2%n1 == 0) return n1;
                n2 %= n1;
                continue;
            }
        }
    }
```

人家的GCD：
```java
    public int GCD (int a, int b) {
        return b == 0 ? a : GCD(b, a % b);
    }
```
。。。。。。

## 994. 腐烂的橘子

本题跟树结构并不完全相同，因为可能有新鲜的橘子会被两个方向的腐烂的橘子感染，此时不能理解成树结构而是图结构

本题跟MST思路较类似，从所有腐烂橘子为源头，连接到所有新鲜的橘子，每条连线权重为1，找到拥有最大权重之和的节点

同样可以使用BFS的方式进行寻找，维护一个腐烂橘子队列，每次拿出一个，将与其相邻的新鲜橘子放入队列

这样就避免DFS可能会出现两个腐烂橘子一起感染一个新鲜的橘子的时间不对的问题

例如：2-1-1-1-2

DFS时，感染路径2-1-1-1，用时3分钟；感染路径1-1-1-2：用时3分钟。但正确用时是2分钟（两个烂橘子一起感染）

BFS时则不会：1分钟时 2-1 / 1-2； 2分钟时2-1-1 / 1-2 感染完毕

## 5323. 根据数字二进制下1的数目排序

想了半天才反应过来这本质还是个排序问题。。。跟平常的排序不一样的地方就是判断大小
的依据变成了二进制下1的数目而已

然而我已经忘记怎么写快排了。。。瞎jb对付了一个冒泡排序暴力过了

（待更新标准解法

## 5325. 包含所有三种字符的子字符串数目

```java
    long all_sub = s.length()*(s.length()+1)/2;
```

太草了，最后一分钟提交结果卡在这个int乘法溢出上，佛了

问题出在虽然结果被声明为long了，但是计算时s.length()仍然是按int类型计算，
所以进行乘法的时候还是会溢出，这里需要先把这个字符串的长度变为long，
然后进行乘法计算，long的话乘法就不会有溢出问题了

```java
    long len = s.length();
    long all_sub = len*(len+1)/2;
```

我的做法见韦恩图。。。不知道有没有更快的解法

![](./Asset/Q5325.jpeg)

## 面试题57 - II. 和为s的连续正数序列

不知道为啥理论上都是O(N)的算法，时间却差的很多。。。

在这里，我们考虑以9为例子，9可以被拆开成4+5。为了得到4我们需要思考一下。
根据规律如果是\[4,5\]的话，i=2，target % 2 = 0 其中\[4,5\]可以改写成4+(4+1)。 
在考虑三个元素的时候 2+3+4 我们发现 他可以被写成 2+(2+1)+(2+2) target%3 = 0。

似乎有点规律，我们不妨用开始元素x元素个数 你会发现如果target刚好为这个值的话，也能满足target%i=0 

那我们如何让target的值等于我们需要的值呢？根据刚才的变式，我们发现只要让target逐次减去(1,2,3,....)
并且当target%i = 0 的时候返回这个target/i就是我们需要的值了。

## 面试题59 - II. 队列的最大值

![](./Asset/Q_59.gif)

插入操作虽然看起来有循环(从尾部逐个去掉辅助双端队列中比插入元素小的元素)，
做一个插入操作时最多可能会有n次出队操作。

但要注意，由于每个数字只会出队一次，因此对于所有的n个数字的插入过程，
对应的所有出队操作也不会大于n次。

因此将出队的时间均摊到每个插入操作上，时间复杂度为 O(1)。
