## 202. 快乐数

- Floyd判圈算法：

一个可以在有限状态机、迭代函数或者链表上判断是否存在环，求出该环的起点与长度的算法。

如果有限状态机、迭代函数或者链表上存在环，那么在某个环上以不同速度前进的2个指针必定会在某个时刻相遇。
同时显然地，**如果从同一个起点(即使这个起点不在某个环上)同时开始以不同速度前进的2个指针最终相遇，
那么可以判定存在一个环**，且可以求出2者相遇处所在的环的起点与长度。

## 204. 计数质数

- 厄拉多塞筛法

如求N之内的质数，首先列出2~N-1的所有数，**如果当前数为质数，则其倍数就是质数，将其所有小于N的倍数排除即可**

例如：

第一个质数为2，在2上画圈，其倍数4/6/8...不是质数，划掉4/6/8...，继续遍历

下一个质数为3，在3上画圈，其倍数6/9/12...不是质数，划掉6/9/12...，继续遍历

下一个质数为5，在5上画圈，其倍数10/15/20...不是质数，划掉10/15/20...，继续遍历

下一个质数为7，在7上画圈，其倍数14/21/28...不是质数，划掉14/21/28...，继续遍历

下一个质数为...

不需要特地判断当前数字（如：i）是否为质数，如果i在之前没有被划掉，则i就是质数

**证明：因为如果i不是质数（没被划掉），则i一定拥有一个小于i的因子（如：j, j<i），
而之前遍历到j的时候就应该已经划掉i（i=k*j）了，矛盾**

所以如果一个数（i）在之前没被划掉，则它一定是质数

将遍历时遇到没被划掉的数字计数，则得到小于N的质数的总数

## 205. 同构字符串

Tips:

1. 遍历字符串时，先将字符串转为数组再访问会比直接访问字符串中的每个字符快

```java
// 遍历字符串：
...
        for (int i = 0; i < len; i++) {
            c1 = s.charAt(i);
            c2 = t.charAt(i);
...

// 遍历数组：
...
        char[] arr1 = s.toCharArray();
        char[] arr2 = t.toCharArray();

        for (int i = 0; i < len; i++) {
            c1 = arr1[i]-' '+1;
            c2 = arr2[i]-' '+1;
...
```

2. 空间允许时，直接使用一个很大长度的数组比使用Hashmap更快
```java
// Hashmap
...
        Map map = new HashMap();
        ...
        
            if (map.containsKey(c1)) {
                if ((char) map.get(c1) != c2) return false;
            } else if (map.containsValue(c2)) return false;
            else {
                map.put(c1, c2);
            }
...
         
// int[]
...
        int[] map1 = new int[100];
        int[] map2 = new int[100];
        ...
        
            if (map1[c1] != 0) {
                if (map1[c1] != c2) return false;
            }
            else if (map2[c2] != 0) {
                if (map2[c2] != c1) return false;
            }
            else {
                map1[c1] = c2;
                map2[c2] = c1;
            }
...
```
（使用数组的话无法像Hashmap一样使用Hashmap.containsValue()，所以使用两个数组避免遍历查找value）

## 206. 反转链表

迭代的话很好写，递归很tricky

错误的想法是每次递归返回一个逆转链表的头和尾，然后把节点一个个加在逆转链表的尾部；

这样写由于每次return的必须有头节点（否则最后得到结果只有链表的尾节点）和尾节点（不然无法快速把一个节点附加在逆转链表尾部）

tricky的做法是返回的不是一个标准的链表，而只是后半部分连接顺序反向的V字形链表，
**正向链表和反向链表指向同一个尾节点，每次递归将这个尾节点向左移动，即只改变正向部分最后一个节点和逆向部分最后一个节点间指向的方向**

**每次递归结束之后正向部分节点数-1，逆向部分节点数+1**

这样做无需每次递归保留头节点和尾节点的信息了，因为在每次递归中：

**head是正向部分的最后一个节点，而head指向的下一个节点又是逆向链表的尾节点**，
这样就不需要特地保存逆向链表的尾节点信息了

并且**每次递归只是把这个head节点加在逆向链表的尾节点之后，返回的仍旧是逆向链表的头节点（tail，表示整个链表的尾部最后一个节点）**

`head.next.next = head;`
head.next是逆向部分的最后一个节点，head.next.next = head等于给逆向部分增加一个head节点

`head.next = null;` 最后将head指向null，将head节点从正向链表上拆下来

等于只是将head与head.next两个节点的指向方向逆转一下，每次递归逆转一对节点间连接的方向，
最后递归完成时整个链表被逆转


- 递归

递归版本稍微复杂一些，其关键在于反向工作。假设列表的其余部分已经被反转，现在我该如何反转它前面的部分？

假设列表为：

n1 → ... → nk−1 → nk → nk+1 → ... → nm → null
​	
若从节点nk+1到nm已经被反转，而我们正处于nk
 
n1 → ... → nk−1 → nk → nk+1 ← ... ← nm
 
我们希望nk+1的下一个节点指向nk；所以，nk.next.next = nk

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        if (head == null) return null;
        if (head.next == null) return head;

        ListNode tail = reverseList(head.next);
        head.next.next = head; // fuck this step, bitch ass tricky
        head.next = null;
        
        return tail;
    }
}
```

## 217. 存在重复元素

- 猴子算法（纯搞笑...）

"我来搞笑了，随机算法，掷10万次2个骰子（面数等于数组长度--等于从数组中随机抽两个数出来），
万一发现有一次一样的就有，10万次都不一样就当做不存在重复吧，特殊案例再处理一下。"

蒙特卡洛：
如果存在重复并且抽样的次数足够多，
大概率存在某一次正好可以将重复的两个元素抽出来。

## 219. 存在重复元素 II

- 哈希表

错误样例：{1,0,1,1}

原因：1出现第二次时没有及时更新索引为2，导致1第三次出现时还是按照第一次的索引0计算距离

注意元素可能出现不止两次，所以出现第二次时要更新哈希表中索引位置（更换为靠后的那个索引），
不然出现第三次时还是按第一次出现的位置计算，导致结果错误

- 集合

思路

用散列表来维护这个k大小的滑动窗口。

算法

遍历数组，对于每个元素做以下操作：在散列表中搜索当前元素，如果找到了就返回 true。
在散列表中插入当前元素。如果当前散列表的大小超过了k， 删除散列表中最旧的元素。
返回 false。

## 231. 2的幂

利用位运算可以在O(1)内解出问题

解题思路：

若 n=2^x 且x为自然数（即 n 为 2 的幂），则一定满足以下条件：
1. 恒有 n & (n - 1) == 0，这是因为：n 二进制最高位为 1，其余所有位为 0；
n−1 二进制最高位为 0，其余所有位为 1；
2. 一定满足 n > 0。

因此，通过 n > 0 且 n & (n - 1) == 0 即可判定是否满足 n=2^x

| 2^x | n | n-1 | n & (n-1) |
| --- | --- | --- | --- |
| 2^0 | 0001 | 0000 | 0000 |
| 2^1 | 0010 | 0001 | 0000 |
| 2^2 | 0100 | 0011 | 0000 |
| 2^3 | 1000 | 0111 | 0000 |
| ... | ...  | ...  | ...  |
